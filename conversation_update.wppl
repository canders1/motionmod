// COMMAND LINE ARGS

var world_sampling = process.argv[1]
var cg_shared = process.argv[2]
var n_moves = process.argv[3]

// PRINT UTILITIES

//prints json objects
var stringify = function(x){return JSON.stringify(x)}

var printU = function(u){
  console.log("Utterance: "+stringify(u));
}

var printW = function(w){
  console.log("World: "+stringify(w));
}

//prints cost, utterance, evidence pairs
var printOne = function(x,f,c){
  console.log("Cost: "+c)
  console.log("Utterance: "+stringify(x));
  console.log("Evidence: "+stringify(f(x)));
  return
}

// iterates through array and prints all members
var printAll = function(arr,f,c){
  map(function(x){printOne(x,f,c)},arr);
  return
}

// PROB UTILITIES

// argmax

var argmax  = function(arr){
  var init = { currentIndex: arr.length-1, maxIndex: 0, maxValue: arr[0] };
  var a = reduce(function(elt, acc) {
    if (elt > acc.maxValue) {
      return { currentIndex: acc.currentIndex - 1, maxIndex: acc.currentIndex, maxValue: elt };
    }
    else {
       return { currentIndex: acc.currentIndex - 1, maxIndex: acc.maxIndex, maxValue: acc.maxValue };
    }
  }, init, arr);
return a.maxIndex;
};

// returns the index of the probability in array 1 with the greatest positive difference from array 2 (it is higher in arr 1 than arr 2)
var getHighestDiffProb = function(a1,a2){
  var probDiffs = map2(function(p1,p2){p1-p2},a1,a2);
  var maxDiffIdx = argmax(probDiffs);
  return maxDiffIdx;
}

// returns the index of the probability in Dist. 1 with the greatest positive difference from Dist. 2 (it is higher in Dist. 1 than Dist. 2)
var getHighestDiffDist = function(d1,d2){
  var a1 = normalizeDistProbs(d1);
  var a2 = normalizeDistProbs(d2);
  var probDiffs = map2(function(p1,p2){p1-p2},a1,a2);
  var maxDiffIdx = argmax(probDiffs);
  return maxDiffIdx;
}


// returns a normalized probability distribution from a webppl distribution object
var normalizeDistProbs = function(dist){
  var prob_weights = dist['params']['ps']
  var prob_sum = sum(prob_weights)
  var probs = map(function(x){x/prob_sum},prob_weights);
  return probs
}

// returns a normalized probability distribution from an array of probability weights
var normalizeProbs = function(weights){
  var prob_sum = sum(weights)
  var probs = map(function(x){x/prob_sum},weights);
  return probs
}

// returns the entropy of a distribution
var findEntropy = function(dist){
  var probs = normalizeDistProbs(dist);
  console.log(probs);
  var log_probs = map(function(x){Math.log2(x)},probs);
  console.log(log_probs);
  var prob_products = map2(function(x,y){x*y},probs,log_probs);
  console.log(prob_products);
  var prob_sum = sum(prob_products);
  return -prob_sum
}

// returns the most likely utterance from distribution d
var maxU = function(d){
  var uts = d['params']['dist']
  var keys = Object.keys(uts)
  var us = map(function(k){uts[k]['val']['utterance']},keys)
  var probs = map(function(k){uts[k]['prob']},keys)
  var pairs = map2(function(x,y){return {'utterance' : x, 'prob':y}},us,probs)
  var pMax = reduce(function(x,y){return x['prob']>y['prob']?x:y}, {'utterance' : '', 'prob': 0},pairs)
  return pMax
}

// retrieves the posterior distribution
var getPosteriors = function(interpretation,worlds){
  var int = interpretation['params']['dist']
  var keys = Object.keys(int)
  var probs = map(function(k){int[k]['prob']},keys)
  var ws= map(function(k){int[k]['val']},keys)
  var posts = map(function(x){var idx = ws.indexOf(x); if(idx!= -1){return probs[idx]}else{return 0}},worlds)
  return posts
}

// calculates an posterior distribution over worlds where the prior is updated according to a learning rate
var wUpdate = function(worldPriors,worldPosteriors,lr){
  var updates = map2(function(post,prior){prior+(post*lr)},worldPosteriors,worldPriors)
  var u_sum = sum(updates)
  var updatedWorlds = map(function(u){u/u_sum},updates)
  return updatedWorlds
}

// returns a posterior distribution where world w has all of the probability weight
var getWPosteriorsS = function(w,worlds){
  var posts = map(function(x){if(x==w){1}else{0}},worlds)
  return posts
}

// DISTRIBUTIONS

// world set
var worlds = [
  {"Major": "German", "School": "University of New Orleans", "Name": "Nancy", "Location Preference": "outdoor"},
  {"Major": "Astronomy", "School": "Franklin Pierce Law Center", "Name": "Nathan", "Location Preference": "outdoor"}, 
  {"Major": "German", "School": "State University of New York at Buffalo", "Name": "Daniel", "Location Preference": "outdoor"}, 
  {"Major": "Hispanic-American Studies", "School": "Franklin Pierce Law Center", "Name": "Gerald", "Location Preference": "outdoor"}, 
  /*{"Major": "Ceramic Engineering", "Company": "Commercial Metals Company","Name": "Nathan", "Location Preference": "outdoor"}, 
  {"Major": "Adult & Continuing Education", "School": "Canisius College", "Name": "Gary", "Location Preference": "indoor"}, 
  {"Major": "Veterinary Sciences", "School": "Marymount University", "Name": "Gary", "Location Preference": "outdoor"}, 
  {"Major": "Electrical Engineering", "School": "University of Dallas", "Name": "Gary", "Location Preference": "outdoor"}, 
  {"Major": "Astronomy", "School": "Saint Mary's College of California", "Name": "Nathan", "Location Preference": "outdoor"},
  {"Major": "Social Work & Social Services", "Company": "Commercial Metals Company","Name": "Mary","Location Preference": "outdoor"}*/
  ]

// world priors
var initWorldPriors = [1,1,1,1,1,1,1,1,1,1];

// returns world distribution
var getWorldDist = function(worlds,worldPs) {
	return Categorical({ps: worldPs,vs: worlds})
}

// utterance set
var utterances = [
'They are a student',
//'They work',
'They are female',
'They are male',
'Their name starts with N',
//'Their name is Nancy',
//'Their name is Nathan',
//'Their name is Daniel',
//'Their name is Gary',
//'Their name is Gerald',
//'Their name is Mary',
//'They study German',
//'They study Astronomy',
//'They study Veterinary Sciences',
//'They study Engineering',
//'They study a social science',
'They study a humanity',
'They study a science',
'They like being outdoors',
//'They like being indoors',
'NULL'
]

//utterance priors are even

//returns utterance distribution
var uttPrior = function() {
	return uniformDraw(utterances)
};

// utterance cost function
var utteranceCost = function(utterance) {
  return 0
}

// interpretation function
var get_meaning = function(utterance, world){
  if ((utterance == 'They are a student' && world["Company"] == undefined) ||
   (utterance == 'They work' && world["Company"] != undefined) ||
   (utterance == 'They are female' && (world["Name"] == 'Nancy' || world["Name"] == 'Mary')) ||
   (utterance == 'They are male' && (world["Name"] != 'Nancy' && world["Name"] != 'Mary')) ||
   (utterance == 'Their name is Nathan' && world["Name"] == 'Nathan') ||
   (utterance == 'They study German' && world["Major"] == 'German') ||
   (utterance == 'They study a science' && (world["Major"] == 'Ceramic Engineering' || world["Major"] == 'Astronomy' || world["Major"] == 'Electrical Engineering' || world["Major"] == "Veterinary Sciences")) ||
   (utterance == 'They study a humanity' && (world["Major"] == "German" || world["Major"] == "Hispanic-American Studies")) ||
   (utterance == 'They study a social science' && (world["Major"] == "Adult & Continuing Education" || world["Major"] == "Social Work & Social Services")) ||
   (utterance == 'Their name starts with N' && (world["Name"] == 'Nathan' || world["Name"] == 'Nancy')) ||
   (utterance == 'They like being outdoors' && world["Location Preference"] == "outdoor") ||
   (utterance == 'They like being indoors' && world["Location Preference"] == "indoor") ||
   (utterance == 'NULL')
   ){
  	return 1
} else {
  return 0
}
}

// RSA MODEL LEVELS

// literal listener: p(w|u) \propto p(u|w)p(w) where p(u|w) is truth value of u in w
var literalListener = function(utterance,worldDist){
   return Infer({model: function(){
   var w = sample(worldDist)
   var meaning = get_meaning(utterance,w)
   condition(meaning)
   return w
   }})
};

// pragmatic speaker: p(u|w) \propto p(w|u)p(u) where p(u) is uniform and p(w|u) is given by literalListener
var pragmaticSpeaker = function(world,worldDist) {
  return Infer({model: function(){
    var utt = uttPrior()
    factor(literalListener(utt,worldDist).score(world))
    return {utterance: utt}
  }})
}

// pragmatic listener: p(w|u) \propto p(u|w)p(w) where p(u|w) is given by pragmaticSpeaker
var pragmaticListener = function(u,worldDist) {
  return Infer({model: function(){
    var w = sample(worldDist)
    factor(pragmaticSpeaker(w,worldDist).score({utterance:u}))
    return w
  }})
}

// CONTEXT UPDATE 

//initialize distributions
// currently assumes CG is shared and starts out with uniform priors

var init_distributions = function(speaker_priors,listener_priors,world_set){
  var all_priors = {speaker_beliefs: getWorldDist(world_set,speaker_priors),
    listener_beliefs: getWorldDist(world_set,listener_priors),
    cg: getWorldDist(world_set,map(function(x){1},world_set))}
  return all_priors
}

// simulate a speaker observation by sampling a world
// currently assumes worlds are sampled in proportion to their probability in speaker belief dist.

var sample_world = function(speaker_priors,cg,worlds,sampler){
  console.log(sampler);
  if (sampler == 'weighted') {
    return sample(speaker_priors);
  }
  if (sampler == 'difference'){
    var biggest_diff = getHighestDiffDist(speaker_priors,cg);
    console.log(biggest_diff);
    return worlds[biggest_diff];
  }
}

//speaker calculates which utterance to select

var pick_utterance = function(w,cg){
  var u = maxU(pragmaticSpeaker(w,cg))["utterance"];
  printU(u);
  return u
}

// listener interprets utterance (also: speaker models listener interpreting utterance)

var interpret_utterance = function(u,cg){
  var posteriors = getPosteriors(pragmaticListener(u,cg),cg['params']['vs']);
  printW(posteriors);
  return posteriors;
}

// update CG with interpretation of utterance
// currently assumes a shared CG and a fixed learning rate

var update_cg = function(cg,posteriors,lr){
  var cg_priors = cg['params']['ps'];
  var cg_worlds = cg['params']['vs'];
  var updated_weights = map2(function(post,prior){prior+(post*lr)},posteriors,cg_priors);
  var cg_posts = normalizeProbs(updated_weights);
  return getWorldDist(cg_worlds,cg_posts)
}

//TO DO: fix below

// runs n steps in a conversation where listener and speaker have shared priors
var simulateSharedDist = function(n_gens,curr_n,pref,spb,sp,lp){
  if(n_gens != curr_n){
    console.log("Belief: "+stringify(worlds[pref]))
    var newPriors = run_generation(curr_n,spb,sp,lp)
    console.log("Speaker dist: " + newPriors['sp'])
    console.log("Listener dist: " + newPriors['lp'])
    simulateSharedDist(n_gens,curr_n+1,pref,spb,newPriors['sp'],newPriors['lp'])
  } else {
    return 
  }
}

var runConversation = function(n_gens,cg,speaker_beliefs,listener_beliefs,sampler){
  console.log("Speaker beliefs: ")
  console.log(speaker_beliefs['params']['ps']);
  console.log("Listener beliefs: ")
  console.log(listener_beliefs['params']['ps']);
  return runConversationHelper(0,n_gens,cg,speaker_beliefs,listener_beliefs,sampler);
}

var runConversationHelper = function(curr_gen,n_gens,cg,speaker_beliefs,listener_beliefs,sampler){
  if (curr_gen == n_gens){
    console.log("Final Common Ground: ")
    console.log(cg['params']['ps']);
    return
  } else {
    console.log("Generation "+curr_gen);
    console.log("Current Common Ground: ");
    console.log(cg['params']['ps']);
    var world_set = cg['params']['vs'];
    console.log(world_set);
    var sampled_w = sample_world(speaker_beliefs,cg,world_set,sampler);
    console.log("Observed world:");
    console.log(sampled_w);
    var selected_u = pick_utterance(sampled_w,cg)
    console.log(selected_u);
    var int_posteriors = interpret_utterance(selected_u,cg);
    var new_cg = update_cg(cg,int_posteriors,0.05);
    runConversationHelper(curr_gen+1,n_gens,new_cg,listener_beliefs,speaker_beliefs,sampler);
  }
}

// RUN CALL

//console.log(argmax([10, 30, 20, 10]));
//console.log(getHighestDiffProb([0.1,0.2,0.3,0.4],[0.01,0.1,0.1,0.15]));
var initial_dists = init_distributions([10,1,1,1],[1,1,1,10],worlds);
var cg = initial_dists['cg'];
var speaker_beliefs = initial_dists['speaker_beliefs'];
var listener_beliefs = initial_dists['listener_beliefs'];
runConversation(5,cg,speaker_beliefs,listener_beliefs,'weighted');
